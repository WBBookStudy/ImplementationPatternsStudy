# 09. 컬렉션
 - 컬렉션 구현은 주로 성능에 관련된 의도를 전달한다.
 - 컬렉션은 데이터의 변형이나 몇개의 데이터를 사용하느냐를 표현하고 있다.
 - 어떤 컬렉션을 사용하느냐에 따라 프로그래머는 다양한 정보를 독자에게 전달 할 수 있다.

## 메타포
컬렉션에는 여러 종류의 메타포가 녹아있다.
### 1. 여러 값을 가진 변수
 - 컬렉션 변수는 여러 객체를 한번에 가리키는 역할을 한다.
 - 여느 변수와 마찬가지로 컬렉션 변수에도 값을 할당하고, 값을 얻어올수 있으며 변수 메세지를 보낼 수 있다.

### 2. 객체
 - 컬렉션의 값을 얻는것도 가능하고, 인자로 전달하는것도 가능하며 동등성 테스트, 메세지 보내기가 가능하다.
 - 컬렉션은 여러 관련있는 인터페이스와 구현의 집합이므로 확장된 인터페이스와 새로운 구현을 통해 확장이 가능하다. 
 - 변수 값이 아닌 변수 자체를 인자로 전달하는 참조 호출이 가능하다.
 - 참조 호출은 예상치 못한 결과를 가져올수 있으므로 이런 상황을 피하기 위해 컬렉션 사용에는 몇가지 규범이 있다.

### 3. 수학적 집합
 - 수학의 집합이 여러 원소의 모임인 것과 마찬가지로 컬렉션은 객체의 모임이다.
 - 집합 메타포를 모두 컬렉션에 적용하지는 않고, 크기(size())를 구하는 것이나, 집합에 속해있는지 알아보는(contains())것 등의 부분적으로만 적용하고 있다.

## 이슈
 - 컬렉션을 사용할때에는 가급적 가장 일반적인 인터페이스를 사용해서 선언하고, 가장 구체적인 구현 클래스를 사용하는 것이 좋다.
 - 같은 객체를 Iterable, Collection, List등 다양한 타입을 사용하는 것보다 모든곳에서 List로 선언하는 것이 더 깔끔할 수 있다.
 - 컬렉션의 선택은 성능에 관한 프로그래머의 의도를 전달한다.
 - 적절한 컬렉션 사용은 시간과 공간면에서 모두 프로그램을 최적화 시킬수 있다.

## 인터페이스
### 배열
 - 가장 단순한 컬렉션 인터페이스
 - 배열의 크기는 생성시 고정
 - 단순 연산의 경우 다른 컬렉션에 비해 시간, 공간면에서 효율적이다
 - 다른 컬렉션과 다른 프로토콜을 갖고있어 배열을 다른 종류의 컬렉션으로 별환하는 일이 상대적으로 복잡하다.

### Iterable
 - 지원하는 기능은 순차 열람 뿐이고 크기 측정 메소드도 없다.
 - 수정에 대한 여부를 판단할 수 없고 Iterator를 갖고 있다면 remove()메소드를 사용해서 원소를 제거할 수 는 있다.
 - Iterable의 하위 인터페이스들이 좀더 유용한 기능을 지원한다.

### Collection
 - Iterable을 상속받아 원소 추가, 삭제, 검색, 크기등의 메소드를 추가로 지원한다.
 - addAll(), retainAll(), removeAll()의 결과로 컬렉션 자체를 바꾸는 대신 새로 할당된 컬렉션을 반환한다.

### List
 - Collection을 기반으로 원소간에 정해진 순서을 부여한 것
 - List를 사용하면 컬렉션상에서의 인덱스를 통해 어떤 원소에 접근할 수 있다.
 - 원소 사이의 상호작용(특히 원소간의 순서)이 있는 경우 사용한다.

### Set
 - 중복 원소를 허용하지 않고, 순서가 없는 컬렉션
 - Set에 원소를 추가하면 변경된 컬렉션이 아닌 컬렉션 자체가 바뀐다.
 - 컬렉션에 원소가 속해있는지 여부가 중요하고, 출현 횟수가 중요하지 않은 경우 유용

### SortedSet
 - 중복 원소가 없는 순서가 있는 컬렉션
 - SortedSet는 Comparator에 의해 순서를 정한다. (명시적인 순서를 정하지 않은 경우 기본 정렬)

### Map
 - List처럼 키를 사용해 원소를 저장하고 이때 키는 임의의 객체가 된다.
 - Map의 키는 중복이 불가하지만 원소데이터는 중복 사용이 가능하다.
 - 순서가 보장 되지 않는다.
 - Map은 내부적으로 키에 대한 컬렉션과 데이터에 대한 컬렉션, 2개의 컬렉션을 유지한다.
 - 외재상태나 변수상태에 많이 사용하여 키를 객체로 테이터를 상태로 사용할때 유용하다.

## 구현
 - 컬렉션에 대해 구현 클래스를 선택하는 것은 주로 성능과 관련이 있다.
 - 컬렉션의 크기도 컬렉션 구현시 고려해야할 대상이다.
 - 우선 단순한 구현으로 시작한 후 경험에 따라 튜닝을 하는 것이 좋다.

### Collection
 - Collection 인터페이스에 대한 기본 구현 클래스는 ArrayList이다.
 - ArrayList사용시 성능상 문제가 될만한 부분은 컬렉션의 크기에 비례해서 연산이 커지는 contains()와 이 메소드를 이용하는 다른 메소드들(remove())이다.
 - 이러한 메소드들이 성능을 제약한다면 HashSet으로 바꾸는걸 고려해보는 것이 좋다(중복제거 가능한 경우)

### List
 - Collection 프로토콜에 원소 사이의 순서를 부여한 것
 - List의 구현체중 자주 쓰이는 것으로는 ArrayList, LinkedList가 있다.
 - ArrayList 는 원소 접근이 빠르고, 원소 추가/제거가 느리다.
 - LinkedList는 원소 접근이 느리고, 원소 추가/제거가 빠르다.
 - add()나 remove()가 많은 프로그램이라면 LinkedList를 사용하는 것이 좋다.

### Set
 - 구현체로 HashSet, LinkedHashSet, TreeSet이 많이 쓰인다.
 - HashSet은 가장 빠르지만 원소간 순서를 보장해주지 않는다.
 - LinkedHashSet은 원소간 순서를 삽입된 순서로 보장해 준다. 하지만 추가/삭제시 30% 시간이 더 걸린다.
 - TreeSet은 Comparator에 따라 원소를 정렬하지만 원소추가/삭제 시간이 컬렉션의 크기에 비례해서 커진다.

### Map
 - HashMap은 가장 빠르고 단순하다.
 - LinkedHashMap은 컬렉션에 추가된 원소간의 순서를 보장한다.
 - TreeMap은 키의 순서에 따라서 순차열람이 가능하지만 원소 추가/삭제 시간이 컬렉션의 크기에 비례한다.

## Collections
Collections는 다른 컬렉션 인터페이스에 넣기 적절치 않은 기능들을 모아놓은 유틸 클래스이다.

### 검색
 - indexOf() 연산에 걸리는 시간은 리스트의 크기에 비례한다. 그러나 원소들이 정렬되어 있다면 이진 검색을 사용해서 컬렉션의 크기에 비례하는 시간에 검색할 수 있다.
 - Collections.binarySearch(list, element)를 사용하면 좀더 효율적으로 원소에 대한 인덱스를 구할 수 있다. 해당 원소가 리스트에 없으면 음수를 반환한다.
 - 이진 검색은 ArrayList와 같이 상수 시간에 임의의 접근이 가능한 리스트에 대해서만 향상된 성능을 제공한다.

### 정렬
 - 원소간의 순서를 바꾸는 연산 제공
 - reverse(list) : 리스트에 속해 있는 모든 원소간의 순서를 거꾸로 바꿈
 - shuffle(list) : 순서를 임의로 바꾼다.
 - 정렬을 수행하면 컬렉션의 원소들이 일단 배열로 복사되어 정렬된 후 다시 본래 컬렉션으로 복사되기 때문에 정렬의 성능은 ArrayList, LinkedList 둘다 비슷하다.

### 수정 불가능한 컬렉션
 - 전달되는 컬렉션의 변경을 허용하고 싶지 않을때에 Collections로 래핑한 후 클라이언트가 컬렉션을 수정하려 하면 예외를 발생시키도록 처리 할 수 있다. (Collection, List, Set, Map에도 비슷하게 적용 가능)
```Java
@Test(expected = UnsupportedOperationException.class)
public void unmodifiableThrowException(){
    List<String> II = new ArrayList<String>();
    II.add("zz");

    Collection<String> strings = Collections.unmodifiableCollection(II);
    Iterator<String> all = unmodifiable.iterator();
    all.next();
    all.remove();
}
```

### 단일 원소 컬렉션
 - 하나의 원소를 전달해야하지만 컬렉션 인터페이스를 사용해야 하는 경우, Set을 반환하는 Collections.singleton()을 사용할 수 있다.
```Java
Set<String> short = Collections.singleton("A");
List<String> short = Collections.singletonList("A");
Map<String, String> short = Collections.singletonMap("K", "V");
```

### 무원소 컬렉션
 - 컬렉션 인터페이스를 사용해야 하지만 전달할 원소가 없는 경우에는 Collections에서 수정할 수 없는 무원소 컬렉션을 생성해서 사용할 수 있다.
```Java
Collections.emptyList()
```

## 컬렉션 확장
 - 컬렉션에서 클래스를 상속받아 확장 할 수 있다.
 - 이 경우 컬렉션에서 제공하는 많은 연산들이 클라이언트측에 부적절 할 수 있다. (clear()등)
 - 몇줄 안되는 유용한 구현을 재사용하기 위해, 더 유용하게 사용할 수도 있는 상속을 사용해버릴 수 있다. 이러한 경우 상속보다는 위임을 사용하는 편이 낫다.
```Java
class Library {
    Collection<Book> books = new ArrayList<book>();
}
```
 - 범용 컬렉션 클래스를 구현하는 경우에만 컬렉션을 상속받게 하고, 다른경우에는 위임을 사용해서 내부 컬렉션에 원소들을 저장하라.
